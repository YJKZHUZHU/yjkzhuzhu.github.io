## 设计模式

### 策略模式(行为模式)

> 定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。本模式使得算法可以独立于使用它的客户而变化。

策略是个形象的表述，所谓策略就是方案，我们都知道任何事情都有多种方案，而且不同方案都能解决问题，所以这些方案可以相互替换。我们将方案从问题中抽象出来，这样就可以抛开问题，单独优化方案了，这就是策略模式的核心思想。

#### 一些例子

- 地图导航：我们去任何地方都可以选择步行、骑车、开车、公交，不同的方案都可以帮助我们到达目的地，那么很明显应该将这些方案变成策略封装起来，接收的都是出发点和目的地，输出的都是路线。
- 布局方式：比如我们做一个报表系统，在 PC 使用珊格布局，在移动端使用流式布局，其实内容还是那些，只是布局方式会随着不同终端大小做不同的适配，那么布局的适配就是一种策略，它可以与报表内容无关。我们可以将布局策略单独抽取出来，以后甚至可以适配电视机、投影仪等等不同尺寸的场景，而不需要对其他代码做任何改动，这就是将布局策略从代码中解耦出来的好处。
- sort 排序算法：当我们调用 .sort 时，使用的是什么排序算法？可能是冒泡、快速、插入排序？其实无论何种排序算法，本质上做的事情都是一样的，我们可以事先将排序算法封装起来，针对不同特性的数组调用不同的排序算法。

#### 实战

> 根据不同范围值显示不同的舒适值文案

- 常规思路 if else 一把梭

  ```typescript
  const parseTempLevel = (tempValue: number, tempUnit: string) => {
    const level = tempUnit === '℉' ? [39.2, 64.4, 82.4, 98.6] : [4, 18, 28, 37];
    let status: TempLevelProps;
    if (tempValue <= level[0]) {
      status = TempLevelProps.veryCold;
    } else if (tempValue <= level[1]) {
      status = TempLevelProps.cold;
    } else if (tempValue <= level[2]) {
      status = TempLevelProps.comfortable;
    } else if (tempValue <= level[3]) {
      status = TempLevelProps.hot;
    } else {
      status = TempLevelProps.veryHot;
    }
    return status;
  };
  ```

- 策略模式

  ```typescript
  class Validator {
    constructor(value: number, level: number[]) {
      this.val = value;
      this.level = level;
    }

    level: number[];

    val: number;

    cache: (() => void)[] = [];
    // 策略
    strategies: TypeStrategies = {
      veryCold: () => {
        return this.val <= this.level[0] && TempLevelProps.veryCold;
      },
      cold: () => {
        return (
          this.val <= this.level[1] &&
          this.val > this.level[0] &&
          TempLevelProps.cold
        );
      },
      comfortableByTemp: () => {
        return (
          this.val <= this.level[2] &&
          this.val > this.level[1] &&
          TempLevelProps.comfortable
        );
      },
      hot: () => {
        return (
          this.val <= this.level[3] &&
          this.val > this.level[2] &&
          TempLevelProps.hot
        );
      },
      veryHot: () => {
        return this.val > this.level[3] && TempLevelProps.veryHot;
      },
      veryDry: () => {
        return this.val <= this.level[0] && HumLevelProps.veryDry;
      },
      dry: () => {
        return (
          this.val <= this.level[1] &&
          this.val > this.level[0] &&
          HumLevelProps.dry
        );
      },
      comfortableByHumid: () => {
        return (
          this.val <= this.level[2] &&
          this.val > this.level[1] &&
          HumLevelProps.comfortable
        );
      },
      damp: () => {
        return (
          this.val > this.level[2] &&
          this.val <= this.level[3] &&
          HumLevelProps.damp
        );
      },
      veryDamp: () => {
        return this.val > this.level[3] && HumLevelProps.veryDamp;
      },
    };

    // 添加策略事件
    add = function(method: TypeLevel) {
      this?.cache?.push(
        (method => {
          return this.strategies[method]();
        })(method),
      );
    };
    // 校验策略
    check = function() {
      return this?.cache?.find(Boolean);
    };
  }
  ```

  使用

  ```typescript
  export const parseTempLevel = (tempValue: number, tempUnit: string) => {
    const level = tempUnit === '℉' ? [39.2, 64.4, 82.4, 98.6] : [4, 18, 28, 37];
    const validator = new Validator(tempValue, level);
    validator.add('cold'); // 策略1
    validator.add('comfortableByTemp'); // 策略2
    validator.add('hot'); // 策略3
    validator.add('veryCold'); // 策略4
    validator.add('veryHot'); // 策略5
    return validator.check();
  };
  ```

  这是不是比一直疯狂写 if-else 好太多了呢？还有什么例子？表单验证啊 ~ 对于表单字段（名称、密码、邮箱、....）我们可以使用策略模式去设计优化它，想啥呢，赶紧动手试一下！我都已经手把手教你到这了~

#### 什么时候使用

- 各判断条件下的策略相互独立且可复用
- 策略需要灵活组合
- 策略内部逻辑相对复杂

#### 弊端

不要走极端，不要每个分支走一个策略模式，这样会导致策略类过多。当分支逻辑简单清晰好维护时，不需要使用策略模式抽象。

### 装饰器模式

> 动态地给一个对象添加一些额外的职责**。**是为了给一个函数赋能，增强它的某种能力，它能动态的添加对象的行为，也就是我传入的就是一个对象。毕竟在 JS 的世界中万物皆对象。如天冷了多穿衣服，金币足够了换复活甲

#### 一些例子

- 高阶函数，高阶组件
- 装饰函数
- AOP 装饰函数

#### 实战

- 高阶组件

  ```typescript
  import React from 'react';

  const WithWrapperHOC = (WrapperComponent: any) => {
    return class extends React.Component {
      render() {
        return (
          <div style={{ backgroundColor: 'yellow' }}>
            <WrapperComponent {...this.props} />
          </div>
        );
      }
    };
  };

  const Wrapper = () => {
    return (
      <div>
        <p>我变颜色了</p>
      </div>
    );
  };

  export default WithWrapperHOC(Wrapper);
  ```

- 举个浅显的 🌰。

  ```typescript
  class MyFunc {
    react = function() {
      console.log('我会react');
    };
  }

  class Decorator {
    constructor(old: () => void) {
      this.oldFunc = old;
    }
    oldFunc: () => void;
    vue = () => {
      console.log('我会vue');
    };
    compose = () => {
      this.oldFunc();
      this.vue();
    };
  }

  const myFunc = new MyFunc();
  const decorator = new Decorator(myFunc.react);

  decorator.compose();
  ```

- 装饰函数

  ```typescript
  const func = () => {
    console.log(11);
  };

  // 改成
  const func = () => {
    console.log(11);
    console.log(22);
  };
  ```

  很多时候我们不想去碰原函数，也许原函数是由其他同事编写的，里面的实现非常杂乱。甚至在一个古老的项目中，这个函数的源代码被隐藏在一个我们不愿碰触的阴暗角落里。那有没有在不改变函数源代码的情况下，能给函数增加功能，答案是有的。

  我们可以保存原引用来改写某个函数

  ```typescript
  let func = () => {
    console.log(11);
  };
  const _func = func;
  // 改成
  let func = () => {
    _func();
    console.log(22);
  };
  ```

  这样虽然遵循了封闭-开放原则，但是也引发了其他的问题，

  1. 需要维护\_func 这个变量，但如果函数的装饰链较长，或者需要装饰的函数变多，这些中间变量的数量也会越来越多。
  2. this 劫持问题，因此改方式也不是很保险，也是能解决的通过 call，apply,bind 等手段，来改变 this 指向

- AOP 装饰函数

  ```typescript
  Function.prototype.before = function(beforefn) {
    var __self = this; // 保存原函数的引用
    return function() {
      // 返回包含了原函数和新函数的"代理"函数
      beforefn.apply(this, arguments); // 执行新函数，且保证 this 不被劫持，新函数接受的参数
      // 也会被原封不动地传入原函数，新函数在原函数之前执行
      return __self.apply(this, arguments); // 执行原函数并返回原函数的执行结果，
      // 并且保证 this 不被劫持
    };
  };
  Function.prototype.after = function(afterfn) {
    var __self = this;
    return function() {
      var ret = __self.apply(this, arguments);
      afterfn.apply(this, arguments);
      return ret;
    };
  };
  ```

  Function.prototype.before 接受一个函数当作参数，这个函数即为新添加的函数，它装载了新添加的功能代码。接下来把当前的 this 保存起来，这个 this 指向原函数，然后返回一个“代理”函数，这个“代理”函数只是结构上像代理而已，并不承担代理的职责（比如控制对象的访问等）。它的工作是把请求分别转发给新添加的函数和原函数，且负责保证它们的执行顺序，让新添加的函数在原函数之前执行（前置装饰），这样就实现了动态装饰的效果。我们注意到，通过 Function.prototype.apply 来动态传入正确的 this，保证了函数在被装饰之后，this 不会被劫持。

  Function.prototype.after 的原理跟 Function.prototype.before 一模一样，唯一不同的地方在于让新添加的函数在原函数执行之后再执行。

  - AOP 函数的应用

    1. 数据统计上报

       ```typescript
       Function.prototype.after = function(afterFn: Function) {
         const __self = this;
         return () => {
           const ret = __self.apply(this, arguments);
           afterFn.apply(this, arguments);
           return ret;
         };
       };

       const log = () => {
         console.log('上报标签为: ' + 'button');
       };

       const Wrapper = () => {
         const onReport = () => {
           console.log('点击了按钮');
         };

         return (
           <div>
             <button onClick={onReport.after(log)}>点我上报</button>
           </div>
         );
       };

       export default Wrapper;
       ```

       这样就实现了业务与上报解耦，当然是不太建议直接在原型上新增方法的，可以自己实现一个构造函数。

    2. AOP 动态改变函数参数

       先来实现一个 before 函数

       ```typescript
       Function.prototype.before = function(beforefn: Function) {
         const __self = this;
         return function() {
           // 这里不能使用箭头函数
           // 顺序不要乱了
           beforefn.apply(this, arguments); // (1)
           return __self.apply(this, arguments); // (2)
         };
       };

       const Wrapper = () => {
         var onFetch = (params: any) => {
           console.log(params); // 输出： {a: "a", b: "b"}
         };

         const d = onFetch.before((params: any) => {
           console.log('params=', params);
           params.b = 'b';
         });

         return (
           <div>
             <button onClick={() => d({ a: 'a' })}>发请求</button>
           </div>
         );
       };

       export default WithWrapperHOC(Wrapper);
       ```

       beforefn 和原函数**self 共用一组参数列表 arguments，当我们在 beforefn 的函数体内改变 arguments 的时候，原函数**self 接收的参数列表自然也会变化。

       再来一个场景，给 ajax 动态新增参数，加设有这么一个场景，有一天网站受到了 CSRF 攻击，后端说需要在每个接口参数中新增一个 token 参数校验。

       常规则思路是大概是这样

       ```typescript
       // 这是一个获取token的参数
       const getToken = function() {
         return 'Token';
       };
       // 发送ajax
       const ajax = function(type, url, param) {
         param = param || {};
         Param.Token = getToken(); // 发送 ajax 请求的代码略...
       };
       ```

       虽然已经解决了问题，但我们的 ajax 函数相对变得僵硬了，每个从 ajax 函数里发出的请求都自动带上了 Token 参数，虽然在现在的项目中没有什么问题，但如果将来把这个函数移植到其他项目上，或者把它放到一个开源库中供其他人使用，Token 参数都将是多余的。（是不是每次 copy 代码代码还得多多少少改点）

       ​ 也许另一个项目不需要验证 Token，或者是 Token 的生成方式不同，无论是哪种情况，都必须重新修改 ajax 函数。

       ​ 为了解决这个问题，先把 ajax 函数还原成一个干净的函数：

       ```typescript
       const ajax= function( type, url, param ){
        console.log(param); // 发送 ajax 请求的代码略
       };
       // 然后把 Token 参数通过 Function.prototyte.before 装饰到 ajax 函数的参数 param 对象中：
       var getToken = function(){
        return 'Token';
       }
       ajax = ajax.before(function( type, url, param ){
        param.Token = getToken();
       });
       ajax( 'get', 'http:// xxx.com/userinfo', { name: 'sven' } );
       // 从 ajax 函数打印的 log 可以看到，Token 参数已经被附加到了 ajax 请求的参数中：
       {name: "sven", Token: "Token"}
       ```

       明显可以看到，用 AOP 的方式给 ajax 函数动态装饰上 Token 参数，保证了 ajax 函数是一个相对纯净的函数，提高了 ajax 函数的可复用性，它在被迁往其他项目的时候，不需要做任何修改。

       - 插件试的表单校验

         web 端中，表单校验很常见，通常一个提交操作需要校验表单，发起请求

         最常见的代码，能看到校验和提交都放在一起了，formSubmit 函数在此处承担了两个职责，除了提交 ajax 请求之外，还要验证用户输入的合法性。这种代码一来会造成函数臃肿，职责混乱，二来谈不上任何可复用性

         ```typescript
         const formSubmit = function() {
           // 表单校验
           if (username.value === '') {
             return alert('用户名不能为空');
           }
           if (password.value === '') {
             return alert('密码不能为空');
           }
           var param = {
             username: username.value,
             password: password.value,
           };
           // 发起请求
           ajax('http:// xxx.com/login', param); // ajax 具体实现略
         };
         submitBtn.onclick = function() {
           formSubmit();
         };
         ```

         来优化一下，我们把校验的逻辑都放到了 validata 函数中，但 formSubmit 函数的内部还要计算 validata 函数的返回值，因为返回值的结果表明了是否通过校验。

         ```typescript
         const validate = () => {
           if (username.value === '') {
             alert('用户名不能为空');
             return false;
           }
           if (password.value === '') {
             alert('密码不能为空');
             return false;
           }
         };

         const formSubmit = function() {
           if (!validate()) return false;
           // 发起请求
           ajax('http:// xxx.com/login', param); // ajax 具体实现略
         };

         submitBtn.onclick = function() {
           formSubmit();
         };
         ```

         再来优化一下，使 validata 和 formSubmit 完全分离开来，在这段代码中，校验输入和提交表单的代码完全分离开来，它们不再有任何耦合关系，formSubmit = formSubmit.before( validata )这句代码，如同把校验规则动态接在 formSubmit 函数之前，validata 成为一个即插即用的函数，它甚至可以被写成配置文件的形式，这有利于我们分开维护这两个函数。再利用上面说到的策略模式稍加改造，我们就可以把这些校验规则都写成插件的形式，用在不同的项目当中。

         ```typescript
         Function.prototype.before = function(beforefn) {
           var __self = this;
           return function() {
             if (beforefn.apply(this, arguments) === false) {
               // beforefn 返回 false 的情况直接 return，不再执行后面的原函数
               return;
             }
             return __self.apply(this, arguments);
           };
         };
         var validata = function() {
           if (username.value === '') {
             alert('用户名不能为空');
             return false;
           }
           if (password.value === '') {
             alert('密码不能为空');
             return false;
           }
         };
         var formSubmit = function() {
           var param = {
             username: username.value,
             password: password.value,
           };
           ajax('http:// xxx.com/login', param);
         };
         formSubmit = formSubmit.before(validata);
         submitBtn.onclick = function() {
           formSubmit();
         };
         ```

#### 弊端

- 包装器层次增多，会增加调试成本，我们比较难追溯到一个 bug 是在哪一层包装导致的。（想想高阶组件的调试）

- 组合过程的复杂，要生成过多的对象。性能也会收到影响。因为函数通过 Function.prototype.before 或者 Function.prototype.after 被装饰之后，返回的实际上是一个新的函数，如果在原函数上保存了一些属性，那么这些属性会丢失。代码如下

  ```typescript
  const func = function() {
    alert(1);
  };
  func.a = 'a';
  func = func.after(function() {
    alert(2);
  });
  alert(func.a); // 输出：undefined
  ```

### 代理模式

> 代理模式是为其它对象提供一种代理以**控制**这个对象的访问，具体执行的功能还是这个对象本身，就比如说，我们发邮件，通过代理模式，那么代理者可以控制，决定发还是不发，但具体发的执行功能，是外部对象所决定，而不是代理者决定。

#### 一些例子

- 事件委托，事件代理
- Object.defineProperty /Proxy
- 虚拟代理实现图片懒加载
- http 请求缓存代理

#### 实战

- 虚拟代理实现图片懒加载

  正常加载

  ```typescript
  const myImage = (function() {
    const imgNode = document.createElement('img');
    document.body.appendChild(imgNode);
    return {
      setSrc: function(src: string) {
        imgNode.src = src;
      },
    };
  })();

  myImage.setSrc(
    'https://pic4.zhimg.com/v2-13f1954ad4ddb46d032b371cc1887469_im.jpg?source=32738c0c 2x',
  );
  ```

  正常懒加载

  ```typescript
  const MyImage = (function() {
    const imgNode = document.createElement('img');
    document.body.appendChild(imgNode);
    const img = new Image();
    img.onload = function() {
      imgNode.src = img.src;
    };
    return {
      setSrc: function(src: string) {
        imgNode.src = pp;
        setTimeout(() => {
          img.src = src;
        }, 1000);
      },
    };
  })();
  MyImage.setSrc(
    'https://pic4.zhimg.com/v2-13f1954ad4ddb46d032b371cc1887469_im.jpg?source=32738c0c2x',
  );
  ```

  虚拟代理实现懒加载

  > 在 常规开发中，图片预加载是一种常用的技术，如果直接给某个 img 标签节点设置 src 属性，由于图片过大或者网络不佳，图片的位置往往有段时间会是一片空白。常见的做法是先用一张 loading 图片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到 img 节点里，这种场景就很适合使用虚拟代理。

  ```typescript
  const createImage = (function() {
    const img = document.createElement('img');
    img.width = 100;
    img.height = 100;
    document.body.appendChild(img);

    return function(src: string) {
      img.src = src;
    };
  })();

  const proxyImage = function(fn: (src: string) => void) {
    const image = new Image();
    const defaultImg = pp;

    return function(src: string) {
      fn(defaultImg);

      // 这里加一个延迟，可以更好的看到图片替换的过程。

      setTimeout(function() {
        image.src = src;

        image.onload = function() {
          fn(src);
        };
      }, 2000);
    };
  };

  const proxy = proxyImage(createImage);

  proxy(
    'https://pic4.zhimg.com/v2-13f1954ad4ddb46d032b371cc1887469_im.jpg?source=32738c0c2x',
  );
  ```

  这里并没有改变 createImage，只是在此基础上新增了新的行为，这是符合封闭-开放原则的。即使在后续不需要懒加载功能，或者若干年后网速不在是问题，那我们也只需要去掉代理层即可。给 img 节点设置 src 和图片预加载这两个功能，被隔离在两个对象里，它们可以各自变化而不影响对方。

- http 请求缓存代理

  > 缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果。

  - 计算乘积

    ```typescript
    function mult() {
      let count = 1;
      for (let i = 0, l = arguments.length; i < l; i++) {
        count = count * arguments[i];
      }
      return count;
    }
    ```

    加入缓存代理函数

    ```typescript
    const proxyMult = (function() {
      let cache: Record<string, any> = {};
      return function() {
        var args = Array.prototype.join.call(arguments, ',');
        if (args in cache) {
          return cache[args];
        }
        return (cache[args] = mult.apply(this, arguments));
      };
    })();

    proxyMult(1, 2, 34, 5, 6, 7, 8);
    proxyMult(1, 2, 34, 5, 6, 7, 8);
    ```

    当我们第二次调用 proxyMult( 1, 2, 3, 4 )的时候，本体 mult 函数并没有被计算，proxyMult 直接返回了之前缓存好的计算结果。

    通过增加缓存代理的方式，mult 函数可以继续专注于自身的职责——计算乘积，缓存的功能是由代理对象实现的。

  - 缓存代理用于 ajax 异步请求数据

    我们在常常在项目中遇到分页的需求，同一页的数据理论上只需要去后台拉取一次，这些已经拉取到的数据在某个地方被缓存之后，下次再请求同一页的时候，便可以直接使用之前的数据。显然这里也可以引入缓存代理，实现方式跟计算乘积的例子差不多，唯一不同的是，请求数据是个异步的操作，我们无法直接把计算结果放到代理对象的缓存中，而是要通过回调的方式。有兴趣的可自行 coding 试试

#### 什么时候使用

在 JavaScript 开发中最常用的是虚拟代理和缓存代理。虽然代理模式非常有用，但我们在编写业务代码的时候，往往不需要去预先猜测是否需要使用代理模式。当真正发现不方便直接访问某个对象的时候，再编写代理也不迟

- 模块职责单一且可复用
- 两个模块间的交互需要一定限制关系
- 对开销大的对象使用代理，以按需使用。
- 对需要保护的对象进行代理，在代理层做权限控制
- 在对象访问与修改时要执行一些其他逻辑，适合在代理层做。

#### 弊端

- 代理模式会增加微弱的开销，因此请不要将所有对象都变成代理，没有意义的代理只会徒增程序开销。
- 另外代理对象过多，也会导致调试困难，因为代理层的存在，我们往往可能忽略这一层带来的影响，导致忘记这个对象其实是一个代理。

#### 装饰器模式和代理模式的区别

这两种模式都描述了怎样为对象提供一定程度上的间接引用，它们的实现部分都保留了对另外一个对象的引用，并且向那个对象发送请求。

​ 代理模式和装饰者模式最重要的区别在于它们的意图和设计目的。代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。装饰者模式的作用就是为对象动态加入行为。换句话说，代理模式强调一种关系（Proxy 与它的实体之间的关系），这种关系可以静态的表达，也就是说，这种关系在一开始就可以被确定。而装饰者模式用于一开始不能确定对象的全部功能时。代理模式通常只有一层代理  本体的引用，而装饰者模式经常会形成一条长长的装饰链。

​ 在虚拟代理实现图片预加载的例子中，本体负责设置 img 节点的 src，代理则提供了预加载的功能，这看起来也是“加入行为”的一种方式，但这种加入行为的方式和装饰者模式的偏重点是不一样的。装饰者模式是实实在在的为对象增加新的职责和行为，而代理做的事情还是跟本体一样，最终都是设置 src。但代理可以加入一些“聪明”的功能，比如在图片真正加载好之前，先使用一张占位的 loading 图片反馈给客户。

### 发布订阅模式

> 发布-订阅是一种消息范式，消息的发布者，不会将消息直接发送给特定的订阅者，而是通过消息通道广播出去，然后呢，订阅者通过订阅获取到想要的消息。

#### 一些例子

- DOM 事件
- RN 与 app 之间数据的传递会用的比较频繁，如监听设备变更，网络状态，蓝牙状态等等
- RN 中的 DeviceEnentEmitter
- Vue 中的 vm.$on,vm.$emit,vm.\$once

#### 实战

实现一个通用的发布订阅

```typescript
const EventEmit = function() {
  this.events = {};
  this.on = function(name, cb) {
    if (this.events[name]) {
      this.events[name].push(cb);
    } else {
      this.events[name] = [cb];
    }
  };
  this.trigger = function(name, ...arg) {
    if (this.events[name]) {
      this.events[name].forEach(eventListener => {
        eventListener(...arg);
      });
    }
  };
};
```

#### 什么时候使用

- 各模块相互独立
- 存在一对多的依赖关系
- 依赖模块不稳定、依赖关系不稳定
- 各模块由不同的人员、团队开发

#### 优点

​ 它的应用非常广泛，既可以用在异步编程中，也可以帮助我们完成更松耦合的代码编写。发布—订阅模式还可以用来帮助实现一些别的设计模式，比如中介者模式。从架构上来看，无论是 MVC 还是 MVVM，都少不了发布—订阅模式的参与，而且 JavaScript 本身也是一门基于事件驱动的语言。

- 时间上的解耦
- 对象间的解耦

#### 弊端

​ 当然，发布—订阅模式也不是完全没有缺点。创建订阅者本身要消耗一定的时间和内存，而且当你订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。另外，发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一起的时候，要跟踪一个 bug 不是件轻松的事情。

### 适配器模式

> 适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作适配器的别名是包装器（wrapper），这是一个相对简单的模式。在程序开发中有许多这样的场景：当我们试图调用模块或者对象的某个接口时，却发现这个接口的格式并不符合目前的需求。这时候有两种解决办法，第一种是修改原来的接口实现，但如果原来的模块很复杂，或者我们拿到的模块是一段别人编写的经过压缩的代码，修改原接口就显得不太现实了。第二种办法是创建一个适配器，将原接口转换为客户希望的另一个接口，客户只需要和适配器打交道。

#### 一些例子 🌰

- 电源适配器
- USB 转接口
- 多功能排插

#### 实战

有一个通用的 list 组件，多个页面都需要用到这个组件，但是呢，云端返回的数据丢不一样，我只想让我的组件只负责一件事：展示！

每个接口呢数据格式都不一样

接口 A

```typescript
export interface ResourceLocalFileType {
  uuid: string;
  name: string;
  size: number;
  created: number;
  lastModified: number;
  resourceType: number;
  cancel: () => void;
  status: string;
}
```

接口 B

```typescript
export interface ResourcePackageFileType {
  uuid: string;
  materialName: string;
  materialLink: string;
  materialType: number;
  uid?: string;
  ext?: string;
}
```

接口 C

```typescript
export interface ResourcePackageFileType {
  uuid: string;
  materialName: string;
  materialLink: string;
  materialType: number;
  uid?: string;
  ext?: string;
}
```

我的组件呢只支持一种数据结构，这时候就可以使用适配器模式

先统一组件需要接口的数据源格式

```typescript
export interface AdapterResourceType {
  uuid: string;
  created: number;
  fileNo: number;
  fileName: string;
  fileOrigin: string;
  fileStatus: string;
  fileInfo: {
    type: number;
    size?: number;
    [key: string]: any;
  };
  action?: {
    cancel?: () => void;
    [key: string]: any;
  };
}
```

适配器

```typescript
const Adapter = {
  A:(list:ResourceLocalFileType):AdapterResourceType => {
    return list.map(d => {...//逻辑})
  },
  B:(list:ResourcePackageFileType):AdapterResourceType => {
    return list.map(d => {...//逻辑})
  },
  B:(list:ResourcePackageFileType):AdapterResourceType => {
    return list.map(d => {...//逻辑})
  },
}
```

这就是适配器模式，其实我们经常写。。。

#### 弊端

​ 正常开发中，除非万不得已，不然是不推荐使用适配器模式的。适配器模式是一种“亡羊补牢”的模式。但是往往业务开发过程中我们需要适配各种各样的业务需求。

​ 适配器模式是一对相对简单的模式。在本书提到的设计模式中，有一些模式跟适配器模式的结构非常相似，比如装饰者模式、代理模式和外观模式。这几种模式都属于“包装模式”，都是由一个对象来包装另一个对象。区别它们的关键仍然是模式的意图。

- 适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够使它们协同作用。
- 装饰者模式和代理模式也不会改变原有对象的接口，但装饰者模式的作用是为了给对象增加功能。装饰者模式常常形成一条长的装饰链，而适配器模式通常只包装一次。
- 代理模式是为了控制对对象的访问，通常也只包装一次
- 外观模式的作用倒是和适配器比较相似，有人把外观模式看成一组对象的适配器，但外观模式最显著的特点是定义了一个新的接口。

### 享元模式

> 享元（flyweight）模式是一种用于性能优化的模式,享元模式的核心是运用共享技术来有效支持大量细粒度的对象
>
> 如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。在 JavaScript 中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了一件非常有意义的事情

### 单例模式

### 其他模式

- 迭代器模式
- 命令模式
- 组合模式
- 模板方法模式
- 职责链模式
- 终结者模式
- 状态模式

### 参考链接

- https://hejialianghe.gitee.io/jsadvanced/designpattern.html#_4-1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%AE%BA
- https://juejin.cn/post/6844904138707337229#heading-24
- https://zhuanlan.zhihu.com/p/111553641
- https://github.com/ascoders/weekly
- <a href='../../public/设计模式/设计模式.md'>设计模式.md</a>
